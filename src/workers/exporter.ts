/// <reference lib="webworker" />
import JSZip from 'jszip'
import type { ExportOptions, ExportPayload } from '../lib/exportTypes'
import { promptPack } from '../lib/promptPack'
import type { Detection, Objective, Signal } from '../lib/schemas'

function yamlEscape(s: string) {
  return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
}

function toYaml(obj: any, indent = 0): string {
  const pad = '  '.repeat(indent)
  if (obj === null || obj === undefined) return 'null'
  if (typeof obj === 'string') return `"${yamlEscape(obj)}"`
  if (typeof obj === 'number' || typeof obj === 'boolean') return String(obj)
  if (Array.isArray(obj)) {
    return obj.map((v) => `${pad}- ${toYaml(v, indent + 1).replace(/^\s+/, '')}`).join('\n')
  }
  if (typeof obj === 'object') {
    return Object.entries(obj)
      .map(([k, v]) => {
        if (Array.isArray(v)) return `${pad}${k}:\n${toYaml(v, indent + 1)}`
        if (typeof v === 'object' && v !== null) return `${pad}${k}:\n${toYaml(v, indent + 1)}`
        return `${pad}${k}: ${toYaml(v, 0)}`
      })
      .join('\n')
  }
  return `"${yamlEscape(String(obj))}"`
}

function mdObjective(o: Objective) {
  const exabeamLine = (o.exabeamUseCases ?? []).length ? `**Exabeam use cases:** ${(o.exabeamUseCases ?? []).join(', ')}  \n` : ''
  return `# ${o.id}: ${o.name}

**Status:** ${o.status}  
**Telemetry readiness:** ${o.telemetryReadiness}  
${exabeamLine}

## Description
${o.description}

## MITRE mapping
${o.mitre.map((m) => `- ${m.tactic} / ${m.technique}${m.subtechnique ? `.${m.subtechnique}` : ''}`).join('\n')}

## Rationale
${o.rationale ?? '_Not provided_'}

## Notes
Generated by Lite Detection Workbench.
`
}

function mdDetection(d: Detection) {
  return `# ${d.id}: ${d.title}

**Platform:** ${d.platform}  
**Severity:** ${d.severity}  
**Objective:** ${d.objectiveId}  
**Signals:** ${d.signalIds.join(', ') || '_none_'}  

## Detection Content
\`\`\`
${d.content}
\`\`\`

## Tuning notes
${d.tuningNotes ?? '_Not provided_'}

## False positives
${d.falsePositives ?? '_Not provided_'}

## Test plan
${d.testPlan ?? '_Not provided_'}

Generated by Lite Detection Workbench.
`
}

function mdObjectivePack({
  objective,
  detections,
  signals,
}: {
  objective: Objective
  detections: Detection[]
  signals: Signal[]
}) {
  const exabeamLines = (objective.exabeamUseCases ?? []).length
    ? ['## Exabeam use cases', (objective.exabeamUseCases ?? []).map((x) => `- ${x}`).join('\n'), '']
    : []
  const sigLines = signals.length ? signals.map((s) => `- ${s.id}: ${s.name} (${s.logSource})`).join('\n') : '- (none)'
  const detLines = detections.length
    ? detections
        .sort((a, b) => a.id.localeCompare(b.id))
        .map((d) => `- ${d.id}: ${d.title} (${d.platform}, ${d.severity})`)
        .join('\n')
    : '- (none)'

  return [
    `# ${objective.id}: ${objective.name}`,
    '',
    `**Status:** ${objective.status}`,
    `**Telemetry readiness:** ${objective.telemetryReadiness}`,
    '',
    `## Description`,
    objective.description,
    '',
    `## MITRE`,
    objective.mitre.map((m) => `- ${m.tactic} / ${m.technique}${m.subtechnique ? `.${m.subtechnique}` : ''}`).join('\n'),
    '',
    ...exabeamLines,
    `## Signals`,
    sigLines,
    '',
    `## Detections`,
    detLines,
    '',
    `Generated by Lite Detection Workbench.`,
    '',
  ].join('\n')
}

function mdDetectionArtifact(d: Detection) {
  return [
    `# ${d.id}: ${d.title}`,
    '',
    `- platform: ${d.platform}`,
    `- severity: ${d.severity}`,
    `- objectiveId: ${d.objectiveId}`,
    `- signals: ${(d.signalIds ?? []).join(', ') || '(none)'}`,
    '',
    '```',
    d.content,
    '```',
    '',
    `## Tuning notes`,
    d.tuningNotes ?? '_Not provided_',
    '',
    `## False positives`,
    d.falsePositives ?? '_Not provided_',
    '',
    `## Test plan`,
    d.testPlan ?? '_Not provided_',
    '',
    `Generated by Lite Detection Workbench.`,
    '',
  ].join('\n')
}

const ctx = self as unknown as DedicatedWorkerGlobalScope

ctx.onmessage = async (e: MessageEvent<{ payload: ExportPayload; repoName: string; options?: ExportOptions }>) => {
  const { payload, repoName, options } = e.data

  const includeBundles = options?.includeBundles ?? true
  const includeManifests = options?.includeManifests ?? true
  const includePrompts = options?.includePrompts ?? true

  const zip = new JSZip()
  const root = zip.folder(repoName)!

  root.file(
    'README.md',
    `# ${repoName}

This repository was generated by **Lite Detection Workbench** (frontend-only, local-first).
It is **inspired by** concepts from the **OpenTide detection engineering framework** (acknowledgement only; this project is not affiliated with OpenTide).

## Contents
- \`project/project.json\`: canonical project model
- \`objectives/\`: detection objectives
- \`signals/\`: telemetry signal definitions
- \`detections/\`: detection content per platform (Sigma / KQL / CrowdStrike / notes)
- \`docs/\`: generated documentation
- \`bundles/\` (optional): human-friendly packs + summary
- \`bundles/manifests/\` (optional): machine-friendly JSON indexes
- \`.github/prompts/\` (optional): Copilot prompt pack for rule generation

## Next steps
1. Review YAML and detection content.
2. Commit to your Git repo.
3. Use CI workflows to validate/lint (add your own as needed).

`,
  )

  root.file('project/project.json', JSON.stringify(payload, null, 2))

  // Coverage (very lightweight derived)
  const coverage = payload.objectives.map((o) => ({
    objectiveId: o.id,
    status: o.status,
    telemetryReadiness: o.telemetryReadiness,
    mitre: o.mitre,
    platforms: o.platforms,
    detectionCount: payload.detections.filter((d) => d.objectiveId === o.id).length,
  }))
  root.file('project/indexes/coverage.json', JSON.stringify(coverage, null, 2))

  const sigById = new Map(payload.signals.map((s) => [s.id, s] as const))
  const detByObj = new Map<string, Detection[]>()
  for (const d of payload.detections) detByObj.set(d.objectiveId, [...(detByObj.get(d.objectiveId) ?? []), d])

  // Objective-centric export (platform-agnostic structure)
  for (const o of payload.objectives) {
    const oFolder = root.folder(`objectives/${o.id}`)!
    oFolder.file('objective.yaml', toYaml(o) + '\n')
    oFolder.file('README.md', mdObjective(o))

    const ds = detByObj.get(o.id) ?? []
    const sigIds = new Set<string>()
    for (const d of ds) for (const sid of d.signalIds ?? []) sigIds.add(sid)

    const sigFolder = oFolder.folder('signals')!
    for (const sid of Array.from(sigIds).sort()) {
      const s = sigById.get(sid)
      if (!s) continue
      sigFolder.file(`${s.id}.yaml`, toYaml(s) + '\n')
    }

    const detFolder = oFolder.folder('detections')!
    for (const d of ds) {
      detFolder.file(`${d.id}.md`, mdDetectionArtifact(d))
    }

    const docs = root.folder('docs')!
    const ss = Array.from(sigIds)
      .map((id) => sigById.get(id))
      .filter(Boolean) as Signal[]
    docs.file(`${o.id}.md`, mdObjectivePack({ objective: o, detections: ds, signals: ss }))
  }

  if (includePrompts) {
    for (const [path, content] of Object.entries(promptPack)) {
      root.file(path, content + (content.endsWith('\n') ? '' : '\n'))
    }
  }

  if (includeBundles || includeManifests) {
    const bundles = root.folder('bundles')!

    const bySeverity = new Map<string, number>()
    for (const d of payload.detections) bySeverity.set(d.severity, (bySeverity.get(d.severity) ?? 0) + 1)

    const objectiveGaps = payload.objectives.filter((o) => (detByObj.get(o.id) ?? []).length === 0)

    const missingSignals = payload.detections.filter((d) => (d.signalIds ?? []).length === 0)
    const missingTestPlan = payload.detections.filter((d) => !(d.testPlan && d.testPlan.trim().length >= 10))
    const missingFP = payload.detections.filter((d) => !(d.falsePositives && d.falsePositives.trim().length >= 10))

    if (includeBundles) {
      const allMd = payload.detections
        .sort((a, b) => a.id.localeCompare(b.id))
        .map(
          (d) =>
            `## ${d.id} - ${d.title}\n\n**Platform:** ${d.platform}  \\n**Severity:** ${d.severity}  \\n**Objective:** ${d.objectiveId}\n\n\`\`\`\n${d.content}\n\`\`\`\n\n---\n`,
        )
        .join('\n')
      bundles.file('all-detections.md', `# All detections\n\n${allMd}`)

      const severityLines = Array.from(bySeverity.entries())
        .sort((a, b) => b[1] - a[1])
        .map(([k, v]) => `- **${k}**: ${v}`)
        .join('\n')

      const gapLines = objectiveGaps
        .slice(0, 20)
        .map((o) => `- ${o.id} - ${o.name}`)
        .join('\n')

      bundles.file(
        'bundle-summary.md',
        [
          '# Bundle summary',
          '',
          `Generated: ${new Date().toISOString()}`,
          '',
          `## Totals`,
          `- Objectives: ${payload.objectives.length}`,
          `- Signals: ${payload.signals.length}`,
          `- Detections: ${payload.detections.length}`,
          '',
          `## Objective coverage`,
          `- Covered objectives: ${payload.objectives.length - objectiveGaps.length}`,
          `- Gaps: ${objectiveGaps.length}`,
          objectiveGaps.length ? `\nTop gaps (first 20):\n${gapLines}` : '',
          '',
          `## Detections by severity`,
          severityLines || '- (none)',
          '',
          `## Quality gaps (detections needing work)`,
          `- Missing Signals link: ${missingSignals.length}`,
          `- Missing Test Plan: ${missingTestPlan.length}`,
          `- Missing False Positive notes: ${missingFP.length}`,
          '',
          `## Notes`,
          `- This project acknowledges OpenTide concepts for objective-first detection engineering (not affiliated).`,
          '',
        ].join('\n'),
      )

      const objectivePacks = bundles.folder('objectives')!
      for (const o of payload.objectives) {
        const ds = detByObj.get(o.id) ?? []
        const sigIds = new Set<string>()
        for (const d of ds) for (const sid of d.signalIds ?? []) sigIds.add(sid)
        const ss = Array.from(sigIds).map((id) => sigById.get(id)).filter(Boolean) as Signal[]

        const folder = objectivePacks.folder(o.id)!
        folder.file('README.md', mdObjectivePack({ objective: o, detections: ds, signals: ss }))
        folder.file('objective.yaml', toYaml(o) + '\n')
        const signalsFolder = folder.folder('signals')!
        for (const s of ss) signalsFolder.file(`${s.id}.yaml`, toYaml(s) + '\n')
        const detsFolder = folder.folder('detections')!
        for (const d of ds) detsFolder.file(`${d.id}.md`, mdDetectionArtifact(d))
      }
    }

    if (includeManifests) {
      const manifests = bundles.folder('manifests')!
      const mkManifest = (ds: Detection[]) => ({
        generatedAt: new Date().toISOString(),
        counts: {
          detections: ds.length,
        },
        detections: ds.map((d) => ({
          id: d.id,
          title: d.title,
          platform: d.platform,
          severity: d.severity,
          objectiveId: d.objectiveId,
          signalIds: d.signalIds ?? [],
          hasTestPlan: !!(d.testPlan && d.testPlan.trim().length >= 10),
          hasFalsePositives: !!(d.falsePositives && d.falsePositives.trim().length >= 10),
        })),
      })

      manifests.file('all.json', JSON.stringify(mkManifest(payload.detections), null, 2))
      const byObjectiveFolder = manifests.folder('objectives')!
      for (const o of payload.objectives) {
        const ds = detByObj.get(o.id) ?? []
        byObjectiveFolder.file(`${o.id}.json`, JSON.stringify(mkManifest(ds), null, 2))
      }
    }
  }

  const out = await zip.generateAsync({ type: 'uint8array' })
  ctx.postMessage({ ok: true, bytes: out }, [out.buffer])
}
