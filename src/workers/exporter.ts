/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */
import JSZip from 'jszip'
import type { ExportOptions, ExportPayload } from '../lib/exportTypes'
import { promptPack } from '../lib/promptPack'
import type { Detection, Objective } from '../lib/schemas'

function yamlEscape(s: string) {
  return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
}

function toYaml(obj: any, indent = 0): string {
  const pad = '  '.repeat(indent)
  if (obj === null || obj === undefined) return 'null'
  if (typeof obj === 'string') return `"${yamlEscape(obj)}"`
  if (typeof obj === 'number' || typeof obj === 'boolean') return String(obj)
  if (Array.isArray(obj)) {
    return obj.map((v) => `${pad}- ${toYaml(v, indent + 1).replace(/^\s+/, '')}`).join('\n')
  }
  if (typeof obj === 'object') {
    return Object.entries(obj)
      .map(([k, v]) => {
        if (Array.isArray(v)) return `${pad}${k}:\n${toYaml(v, indent + 1)}`
        if (typeof v === 'object' && v !== null) return `${pad}${k}:\n${toYaml(v, indent + 1)}`
        return `${pad}${k}: ${toYaml(v, 0)}`
      })
      .join('\n')
  }
  return `"${yamlEscape(String(obj))}"`
}

function mdObjective(o: Objective) {
  return `# ${o.id}: ${o.name}

**Status:** ${o.status}  
**Telemetry readiness:** ${o.telemetryReadiness}  
**Platforms:** ${o.platforms.join(', ')}  

## Description
${o.description}

## MITRE mapping
${o.mitre.map((m) => `- ${m.tactic} / ${m.technique}${m.subtechnique ? `.${m.subtechnique}` : ''}`).join('\n')}

## Rationale
${o.rationale ?? '_Not provided_'}

## Notes
Generated by Lite Detection Workbench.
`
}

function mdDetection(d: Detection) {
  return `# ${d.id}: ${d.title}

**Platform:** ${d.platform}  
**Severity:** ${d.severity}  
**Objective:** ${d.objectiveId}  
**Signals:** ${d.signalIds.join(', ') || '_none_'}  

## Detection Content
\`\`\`
${d.content}
\`\`\`

## Tuning notes
${d.tuningNotes ?? '_Not provided_'}

## False positives
${d.falsePositives ?? '_Not provided_'}

## Test plan
${d.testPlan ?? '_Not provided_'}

Generated by Lite Detection Workbench.
`
}

const ctx = self as unknown as DedicatedWorkerGlobalScope

ctx.onmessage = async (e: MessageEvent<{ payload: ExportPayload; repoName: string; options?: ExportOptions }>) => {
  const { payload, repoName, options } = e.data

  const includeBundles = options?.includeBundles ?? true
  const includeManifests = options?.includeManifests ?? true
  const includePrompts = options?.includePrompts ?? true

  const zip = new JSZip()
  const root = zip.folder(repoName)!

  root.file(
    'README.md',
    `# ${repoName}

This repository was generated by **Lite Detection Workbench** (frontend-only, local-first).
It is **inspired by** concepts from the **OpenTide detection engineering framework** (acknowledgement only; this project is not affiliated with OpenTide).

## Contents
- \`project/project.json\`: canonical project model
- \`objectives/\`: detection objectives
- \`signals/\`: telemetry signal definitions
- \`detections/\`: detection content per platform (Sigma / KQL / CrowdStrike / notes)
- \`docs/\`: generated documentation
- \`bundles/\` (optional): human-friendly packs + summary
- \`bundles/manifests/\` (optional): machine-friendly JSON indexes
- \`.github/prompts/\` (optional): Copilot prompt pack for rule generation

## Next steps
1. Review YAML and detection content.
2. Commit to your Git repo.
3. Use CI workflows to validate/lint (add your own as needed).

`,
  )

  root.file('project/project.json', JSON.stringify(payload, null, 2))

  // Coverage (very lightweight derived)
  const coverage = payload.objectives.map((o) => ({
    objectiveId: o.id,
    status: o.status,
    telemetryReadiness: o.telemetryReadiness,
    mitre: o.mitre,
    platforms: o.platforms,
    detectionCount: payload.detections.filter((d) => d.objectiveId === o.id).length,
  }))
  root.file('project/indexes/coverage.json', JSON.stringify(coverage, null, 2))

  // Write objects
  for (const o of payload.objectives) {
    root.file(`objectives/${o.id}.yaml`, toYaml(o) + '\n')
    root.file(`docs/${o.id}.md`, mdObjective(o))
  }
  for (const s of payload.signals) {
    root.file(`signals/${s.id}.yaml`, toYaml(s) + '\n')
  }
  for (const d of payload.detections) {
    const folder =
      d.platform === 'sentinel_kql'
        ? 'kql'
        : d.platform === 'sigma_generic'
          ? 'sigma'
          : d.platform === 'crowdstrike_siem'
            ? 'crowdstrike-siem'
            : d.platform === 'crowdstrike_edr'
              ? 'crowdstrike-edr'
              : 'exabeam-cim'
    const ext = folder === 'kql' ? 'kql' : 'yaml'
    root.file(`detections/${folder}/${d.id}.${ext}`, d.content + (d.content.endsWith('\n') ? '' : '\n'))
    root.file(`docs/${d.id}.md`, mdDetection(d))
  }

  if (includePrompts) {
    for (const [path, content] of Object.entries(promptPack)) {
      root.file(path, content + (content.endsWith('\n') ? '' : '\n'))
    }
  }

  if (includeBundles || includeManifests) {
    const bundles = root.folder('bundles')!

    const byPlatform = new Map<string, Detection[]>()
    for (const d of payload.detections) byPlatform.set(d.platform, [...(byPlatform.get(d.platform) ?? []), d])

    const bySeverity = new Map<string, number>()
    for (const d of payload.detections) bySeverity.set(d.severity, (bySeverity.get(d.severity) ?? 0) + 1)

    const detByObj = new Map<string, number>()
    for (const d of payload.detections) detByObj.set(d.objectiveId, (detByObj.get(d.objectiveId) ?? 0) + 1)
    const objectiveGaps = payload.objectives.filter((o) => (detByObj.get(o.id) ?? 0) === 0)

    const missingSignals = payload.detections.filter((d) => (d.signalIds ?? []).length === 0)
    const missingTestPlan = payload.detections.filter((d) => !(d.testPlan && d.testPlan.trim().length >= 10))
    const missingFP = payload.detections.filter((d) => !(d.falsePositives && d.falsePositives.trim().length >= 10))

    if (includeBundles) {
      const allMd = payload.detections
        .sort((a, b) => (a.platform + a.id).localeCompare(b.platform + b.id))
        .map(
          (d) =>
            `## ${d.id} - ${d.title}\n\n**Platform:** ${d.platform}  \\n**Severity:** ${d.severity}  \\n**Objective:** ${d.objectiveId}\n\n\`\`\`\n${d.content}\n\`\`\`\n\n---\n`,
        )
        .join('\n')
      bundles.file('all-detections.md', `# All detections\n\n${allMd}`)

      const platformLines = Array.from(byPlatform.entries())
        .sort((a, b) => b[1].length - a[1].length)
        .map(([k, v]) => `- **${k}**: ${v.length}`)
        .join('\n')

      const severityLines = Array.from(bySeverity.entries())
        .sort((a, b) => b[1] - a[1])
        .map(([k, v]) => `- **${k}**: ${v}`)
        .join('\n')

      const gapLines = objectiveGaps
        .slice(0, 20)
        .map((o) => `- ${o.id} - ${o.name}`)
        .join('\n')

      bundles.file(
        'bundle-summary.md',
        [
          '# Bundle summary',
          '',
          `Generated: ${new Date().toISOString()}`,
          '',
          `## Totals`,
          `- Objectives: ${payload.objectives.length}`,
          `- Signals: ${payload.signals.length}`,
          `- Detections: ${payload.detections.length}`,
          '',
          `## Objective coverage`,
          `- Covered objectives: ${payload.objectives.length - objectiveGaps.length}`,
          `- Gaps: ${objectiveGaps.length}`,
          objectiveGaps.length ? `\nTop gaps (first 20):\n${gapLines}` : '',
          '',
          `## Detections by platform`,
          platformLines || '- (none)',
          '',
          `## Detections by severity`,
          severityLines || '- (none)',
          '',
          `## Quality gaps (detections needing work)`,
          `- Missing Signals link: ${missingSignals.length}`,
          `- Missing Test Plan: ${missingTestPlan.length}`,
          `- Missing False Positive notes: ${missingFP.length}`,
          '',
          `## Notes`,
          `- This project acknowledges OpenTide concepts for objective-first detection engineering (not affiliated).`,
          '',
        ].join('\n'),
      )

      for (const [platform, ds] of byPlatform.entries()) {
        const folder = bundles.folder(platform)!
        folder.file('README.md', `# ${platform} pack\n\nGenerated by Lite Detection Workbench.\n\nContains ${ds.length} detections.`)
        for (const d of ds) {
          folder.file(`${d.id}.md`, `# ${d.id} - ${d.title}\n\n**Severity:** ${d.severity}\n\n\`\`\`\n${d.content}\n\`\`\`\n`)
        }
      }
    }

    if (includeManifests) {
      const manifests = bundles.folder('manifests')!
      const mkManifest = (ds: Detection[]) => ({
        generatedAt: new Date().toISOString(),
        counts: {
          detections: ds.length,
        },
        detections: ds.map((d) => ({
          id: d.id,
          title: d.title,
          platform: d.platform,
          severity: d.severity,
          objectiveId: d.objectiveId,
          signalIds: d.signalIds ?? [],
          hasTestPlan: !!(d.testPlan && d.testPlan.trim().length >= 10),
          hasFalsePositives: !!(d.falsePositives && d.falsePositives.trim().length >= 10),
        })),
      })

      manifests.file('all.json', JSON.stringify(mkManifest(payload.detections), null, 2))
      for (const [platform, ds] of byPlatform.entries()) {
        manifests.file(`${platform}.json`, JSON.stringify(mkManifest(ds), null, 2))
      }
    }
  }

  const out = await zip.generateAsync({ type: 'uint8array' })
  ctx.postMessage({ ok: true, bytes: out }, [out.buffer])
}
